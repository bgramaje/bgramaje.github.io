---
title: "CrowPanel (UNCHAIN): LoRaWAN IoT Node for Public Parking Spaces with Dynamic Remote Management"
description: "Low-power device (ESP32-S3 + SX1262 + ultrasonic sensors + e-ink) integrated with ChirpStack to monitor occupancy and enable dynamic use cases for public parking spaces."
date: "2025-12-24"
tags:
  - IoT
  - LoRaWAN
  - ChirpStack
  - ESP32
  - Embedded
  - Smart City
---

import { Alert } from "@/components/ui/alert";

# PARCAR-IoT: LoRaWAN IoT Node for Public Parking Spaces with Dynamic Remote Management

#### As part of the European **[UNCHAIN](https://unchainproject.eu/])** project, I developed a low-power IoT node designed to monitor public parking spaces and enable a remotely managed "dynamic use" model—allowing schedules, rules, and configuration updates without physical intervention.
##### The focus wasn't merely detecting occupancy, but transforming each parking space into an operable resource: measuring, communicating, receiving server-side configuration, and operating reliably in the field for extended periods on battery power.

> This post is written as a portfolio piece: it explains the solution at a high level, key technical decisions, and how it integrates with ChirpStack, without delving into sensitive details or proprietary code.

## 1. Objectives

The system's goal was to provide public parking spaces with a digital operational cycle: knowing whether they're free or occupied, and being able to change permitted usage according to time slots or specific needs (rotation, loading/unloading, temporary reservations, etc.).

For this to work reliably in real-world conditions, two core capabilities were essential:
* **Reliable sensing** (without false positives)
* **Remote management** (updating schedules and calibration without reflashing firmware)

## 2. System Architecture

The solution was built as a complete system with multiple interconnected components:

- **IoT Node**: sensing + local UI + power management
- **LoRaWAN Gateway**: receives uplinks and transmits downlinks via LoRa RF
- **ChirpStack**: LoRaWAN network server managing device registration, uplink processing, and downlink queuing
- **MQTT Broker**: message broker for event distribution between ChirpStack and application services
- **MongoDB Database**: persistent storage for device data, schedules, configurations, and telemetry
- **MeteorJS Application**: web-based platform for writing and managing data in MongoDB, providing user interface for configuration and monitoring
- **Docker Microservice (chstack-mqtt-bridge)**: dedicated service responsible for managing requests and responses between the server and the IoT node, handling protocol translation and command queuing

## 3. Architecture Diagram

```mermaid
%%{init: {
"theme": "base",
"themeVariables": {
    "actorBkg":"#6b8bd1",
    "actorBorder":"#4a6fa5",
    "actorTextColor":"#ffffff",
    "actorLineColor":"#d4d4e4",
    "signalColor":"#d4d4e4",
    "signalTextColor":"#ffffff",
    "textColor":"#d4d4e4",
    "noteBkgColor":"#6a7fa5",
    "noteTextColor":"#d4d4e4",
    "noteBorderColor":"#ffffff"
}
}}%%
sequenceDiagram
participant Node as IoT Node<br/>(ESP32-S3)
participant GW as LoRaWAN<br/>Gateway
participant CS as ChirpStack<br/>(LoRaWAN Network Server)
participant MQTT as MQTT Broker
participant MS as Microservice<br/>(chstack-mqtt-bridge)
participant DB as MongoDB<br/>Database
participant Meteor as MeteorJS<br/>(Web UI)

Note over Node,GW: Uplink Flow
Node->>GW: LoRa RF Uplink
GW->>CS: IP backhaul (forward uplink)
CS->>MQTT: Publish events
MQTT->>MS: Subscribe events
MS->>DB: Read/Write data
Meteor->>DB: Read/Write data

Note over MS,CS: Downlink Flow
MS->>CS: Queue downlinks
CS->>GW: Downlink (RX1/RX2)
GW->>Node: LoRa RF Downlink
```


## 4. IoT Node

The device combines:

- **ESP32‑S3** as the main MCU and lifecycle orchestrator (boot → measure → communicate → sleep)
- **SX-1262** LoRa module for LoRaWAN communication
- **JSN-SR04T** ultrasonic sensor to infer distance and determine occupancy based on configurable thresholds
- **E‑ink display** showcasing the current occupancy status and usage schedule

A significant part of the hardware integration work involved resolving pin mapping and bus conflicts (SPI) when multiple peripherals coexist (e‑ink/SD-slot/radio), ensuring the design remains stable and reproducible.
> For this, the given device acquired was an `ESP32-S3 DevKitC-1` with a custom PCB including the e‑ink display, and an SD-slot for the microSD card. Since the SD-slot was not needed for this project, a modification in the 
library of `arduino-lmic` was made to target the `SPI3` class rather than the default `SPI` class.

## 5. Firmware Architecture (Layered Design)

The firmware was organized in layers with a clear objective: **minimize awake time**, make behavior predictable and **power efficient**.

- **Power/Boot/RTC**: state restoration and determining the "goal" of the current cycle
- **Sensor**: robust measurement when context requires it
- **Schedule**: active usage schedules/rules and associated configurations received remotely
- **LoRaWAN**: transmissions, downlink waiting, and retry control
- **UI**: e‑ink updates only when relevant state changes

## 6. Lifecycle (Step by Step)

At a high level, the node operates as follows:

1. **Boot**: restore persisted state (schedule, thresholds, pending messages, counters)
2. **Decision**: determine whether to synchronize (RSYNC), retry a pending transmission, or execute a "normal" cycle
3. **Measurement**: perform ultrasonic measurement if current usage requires it or if state confirmation is needed for a transmission
4. **Uplink**: send RSYNC / STATUS / PING as appropriate
5. **Downlink**: process RESYNC_RESPONSE / ACK / REBOOT when received
6. **UI**: refresh e‑ink only if there's a real change (different hash)
7. **Deep sleep**: sleep for the calculated duration

## 7. LoRaWAN Messaging Protocol

The protocol was designed with small, purpose-driven messages, separated by FPorts to simplify backend processing and debugging:

- **`RSYNC (uplink)`**: node requests synchronization; includes context so the server can calculate and return schedule/thresholds
- **`RSYNC_RESPONSE (downlink)`**: server returns timestamp/configuration, thresholds, and schedule entries; node persists and applies them
- **`STATUS (uplink)`**: reports distance/occupancy and metadata about active usage
- **`ACK/REBOOT (downlink)`**: confirmation and remote control for safe operation

### 7.1. Typical Sequence (RSYNC → RESYNC_RESPONSE → STATUS)

```mermaid
%%{init: {
"theme": "base",
"themeVariables": {
    "actorBkg":"#6b8bd1",
    "actorBorder":"#4a6fa5",
    "actorTextColor":"#ffffff",
    "actorLineColor":"#d4d4e4",
    "signalColor":"#d4d4e4",
    "signalTextColor":"#ffffff",
    "textColor":"#d4d4e4",
    "noteBkgColor":"#6a7fa5",
    "noteTextColor":"#d4d4e4",
    "noteBorderColor":"#ffffff"
}
}}%%
sequenceDiagram
participant D as Node
participant G as Gateway
participant C as ChirpStack
participant A as App <br> (calendar/rules)

D->>G: Uplink RSYNC
G->>C: Forward uplink
C->>A: Event (RSYNC)
A-->>C: Enqueue RESYNC_RESPONSE
C-->>G: Downlink in RX1/RX2
G-->>D: RESYNC_RESPONSE
D->>G: Uplink STATUS (occupancy + distance)
G->>C: Forward uplink
C->>A: Event (STATUS)
```

## 8. Application (MeteorJS)

### 8.1. What is MeteorJS?

MeteorJS is a full-stack JavaScript framework that provides real-time data synchronization between the client and server. It uses MongoDB as its default database and features a reactive data layer that automatically updates the UI when data changes. This makes it particularly well-suited for applications requiring live monitoring and configuration management, where users need to see device status and telemetry updates in real-time without manual page refreshes.

### 8.2. Core Functionalities

The MeteorJS application serves as the central management and monitoring platform for the parking space IoT nodes. Its core functionalities include:

- **Device Management**: Registration and configuration of IoT nodes, including device metadata, location information, and LoRaWAN credentials.
- **Schedule and Rule Configuration**: Creation and management of usage schedules that define when parking spaces are available, reserved, or have special rules (e.g., loading zones, time-restricted access).
- **Remote Configuration Management**: Dynamic calibration and threshold updates for occupancy detection sensors. Administrators can adjust distance thresholds.
- **Real-time Monitoring Dashboard**: Live visualization of device status, occupancy states, and telemetry data.
- **Downlink Command Queuing**: Interface for administrators to trigger remote actions such as reboots, or configuration updates.

## 9. Occupancy Detection

Occupancy is inferred from distance measurements, but with noise-resistant decision-making:

- Multiple readings are taken and the value is stabilized (median / outlier filtering)
- Readings are compared against **remotely configurable thresholds**, enabling site-specific calibration (height, tilt, reflections) without reflashing
- Measurement isn't always executed: it's activated only when the schedule/usage requires it or when pending messages depend on the state

## 10. Low Power and Persistence

The power design is based on "transactions": wake up, do the minimum necessary, and go back to sleep. To make this viable, critical state is persisted in RTC memory (configuration, schedule, pending messages, hashes), so deep sleep reboots don't break logical continuity.

## 11. Robustness: Retries and Pending Messages

In real-world environments, uplink/downlink losses occur, making retry logic essential:

- Important messages are marked as `pending_message` with a retry counter, persisted in RTC to survive resets
- The application clears the pending flag when the expected confirmation is received, or retries on a subsequent boot if it didn't arrive
- State hashes help prevent spam: if nothing changed, STATUS transmission and e‑ink refresh aren't forced

## 12. Results and Impact

This work transforms a public parking space into a manageable asset: the backend defines usage schedules and the node applies rules and reports occupancy with minimal energy cost and true remote operation.  

As a portfolio piece, the main value lies in the end‑to‑end integration: hardware + low-power firmware + LoRaWAN + ChirpStack operation + calendar/management logic.

> Natural next steps would include: calibration improvements, and deployment/configuration automation in ChirpStack to operate fleets with less friction.
